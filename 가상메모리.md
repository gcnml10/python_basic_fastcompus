## 가상 메모리 (Virtual Memory System)
> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
- 예: 리눅스는 하나의 프로세스가 4GB
- 통상 메모리는 8GB? 16GB?
> 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함

### 가상 메모리가 필요한 이유
- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템 등)
1. 프로그램을 메모리로 로드(load)
2. 프로세스 실행
3. 프로세스 종료 (메모리 해제)
- 여러 프로세스 동시 실행 시스템 (가상 메모리 필요)
1. 메모리 용량 부족 이슈
2. 프로세스 메모리 영역간에 침범 이슈

### 가상 메모리 (Virtual Memory System)
- 가상 메모리: 메모리가 실제 메모리보다 많아 보이게 하는 기술
  + 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  + 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
- 가상 메모리 기본 아이디어
  + 프로세스는 가상 주소르 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸 때만 물리 주소로 바꿔주면 된다
  + virtual address (가상 주소): 프로세스가 참조한느 주소 (모든 프로세스는 0~4GB의 가상 주소를 가짐)
  + physical address (물리 주소): 실제 메모리 주소
- MMU(Memory Management Unit)
  + CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
  + CPU가 특정 프로세스의 공간을 참조할 때, 먼저 가상 주소를 찾고, 이 가상 주소가 어느 물리 주소에 들어있는지 알아낸다.   
  (가상주소:물리주소 변환) 이것을 빠르게 해주는 것이 MMU   
    
  > CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  > 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
  
  ![](http://pds15.egloos.com/pds/201001/24/90/c0098890_4b5c47fb7c7ba.jpg)  
  출처: <http://recipes.egloos.com/5232056>
  
  ## 페이징 시스템(paging system)
  - 페이징(paging( 개념
    + 크기가 돌일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    + 하드웨어 지원이 필요
      * 예) (CPU) Intel x86 tltmxpa(32bit)에서는 4KB, 2MB, 1GB 지원
    + 리눅스에서는 4KB로 paging
    + 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
    
  ### 페이징 시스템)paging system)
  - 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
  - Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음
  - CPU가 가상주소에 접근하려고 하면 가상주소를 보고 page번호를 얻고 PCB에 있는 Page Table에 가서 가상 주소에 매치 되어 있는 물리 주소에 들어가서 실제 데이터를 가져옴
    
 ### 페이징 시스템 구조
 - page 또는 page frame: 고정된 크기의 block(4KB)
 - paging system
  + 가상 주소 v = (p,d)
    * p: 가상 메모리 페이지
    * d: p안에서 참조하는 위치 (4KB의 시작 지점에서 몇번째 인가) 
  + 페이지 크기가 4KB 예
    * 가상 주소의 0비트에서 11비트가 변위 (d)를 나타냄
    * 12비티 이상이 페이지 번호가 될 수 있음
![](https://blog.kakaocdn.net/dn/bArTL3/btqDHsEemjB/98IH0tM5fUQcsVFyoLbeQ0/img.png)
출처:<https://3catpapa.tistory.com/24>
### 페이지 테이블(page table)
- page table
  + 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
  + 가상주소 v = (p,d)라면
    * p: 페이지 번호
    * d: 페이지 처음부터 얼마 떨어진 위치인지
  + paging system 동작
    * 해당 프로세스에서 특정 가상 주소 엑세스를 하려면
      - 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는지 확인
      - page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고(p')
      - p' + d가 실제 물리 주소가 됨
    
### 페이징 시스템과 MMU(컴퓨터 구조)
- CPU는 가상 주소 접근시
  + MMU 하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성시, 페이지 테이블 정보 생성
  + PCB 등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
  + 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  + CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴
    
### 다중 단계 페이징 시스템
- 32bit 시스템에서 4KB페이지를 위한 페이징 시스템은
  + 하위 12bit는 오프셋
  + 상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함
- 페이징 정보를 단계를 나누어 생성
  + 필요없는 페이지를 생성하지 않으면, 공간 절약 가능
- 페이지 번호를 나타내는 bit를 구분해서, 단계를 나눔(리눅스는 3단계, 최근 4단계)

### MMU와 TLB(컴퓨터 구조)
- MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
- TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬(최근에 변환된 가상주소-물리주소 정보를 가지고 있음)
- CPU가 가상주소를 요청하면 MMU가 TLB에 먼저 갔다옴
![](https://qph.fs.quoracdn.net/main-qimg-054c6d6ec14d213d670d5b1239c7abd0.webp)

### 페이징 시스테모가 공유 메모리
- 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약) (프로세스 생성시간 절약)
![](https://media.vlpt.us/images/underlier12/post/aa4f3c2b-5398-4e7b-9ee8-c2f81f4296dc/image.png)
출처:<https://velog.io/@underlier12/OS-27-%EB%8B%A4%EC%A4%91-%EB%8B%A8%EA%B3%84-%ED%8E%98%EC%9D%B4%EC%A7%95>
- 물리 주소 데이터 변경시
  + 물리주소에 데이터 수정 시도시, 물리 주소를 복사할 수 있음 (copy-in-write) (커널, 공유메모리 등 공유 데이터는 물리메모리 공간 공유)
![](https://ifh.cc/g/a2GwbX.png)

### 요구 페이징(Demand Paging 또는 Demanded Paging)
- 프로세스 모든 데이털르 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  + 선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
  + 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (**페이지 교체 알고리즘 필요**) 

### 페이지 폴트 (page fault) (인터럽트)
- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제는 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림
![](https://media.vlpt.us/images/underlier12/post/0716ca91-8c5a-4f87-817c-fd8533603907/image.png)
출처: 한번 만들어 보기 

---

### 페이지 교체 알고리즘
- 최적 페이지 교체 알고리즘(OPTimal Replacement Algorithm)
  + 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
  + 일반 OS에서는 구현 불가
- LRU(Least Recently Used) Page Replacement Algorithm
  + 가장 오래전에 사용된 페이지를 교체 (메모리 지역성,가장 많이 쓰임)
  + OPT 대신 과거 기록을 기반으로 시도
- LFU(Least Frequently Used) Page Replacement Algorithm
  + 가장 적게 사용된 페이지를 내리자
- 페이지 스왑 알고리즘 (NUR - Not Used Recently)
  + LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
  + 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R,M)
    * (0,0)->(0,1)->(1,0)->(1,1) 순으로 페이지 교체
> 스레싱(Thrashing)
  - 과도한 멀티프로그래밍으로 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황
 
---

## 세그멘테이션 (Segmentation)
- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할
  + 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
  - 예: x86 리얼모드
    * CS(Code Segment), DS(Data Segment), SS(Stack Segment), ES(Extra Segment)로 세그먼트를 나누어, 메모리 접근
- 세그먼트 가상주소
  + v = (s,d): s는 세그먼트 번호, d는 블록 내 세그먼트의 변위
![](https://3.bp.blogspot.com/-gAf52zLfPPY/WRcQbtnS1nI/AAAAAAAABRA/lp4Qhp8KN0UWLLITWk76SRkkrvHskn68wCLcB/s1600/Paging_Segmentation.png)
출처: <http://truemind5.blogspot.com/2017/05/14-3.html>

### 참고
- 내부 단편화 (페이지 기법)
  + 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
- 외부 단편화 (세그멘테이션 기법)
  + 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
- 세그멘테이션/페이징 모두 하드웨어 지원 필요
  + 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현
    
    
    
    
    
    
    
    
    
    
    
