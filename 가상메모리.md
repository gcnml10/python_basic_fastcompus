## 가상 메모리 (Virtual Memory System)
> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
- 예: 리눅스는 하나의 프로세스가 4GB
- 통상 메모리는 8GB? 16GB?
> 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함

### 가상 메모리가 필요한 이유
- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템 등)
1. 프로그램을 메모리로 로드(load)
2. 프로세스 실행
3. 프로세스 종료 (메모리 해제)
- 여러 프로세스 동시 실행 시스템 (가상 메모리 필요)
1. 메모리 용량 부족 이슈
2. 프로세스 메모리 영역간에 침범 이슈

### 가상 메모리 (Virtual Memory System)
- 가상 메모리: 메모리가 실제 메모리보다 많아 보이게 하는 기술
  + 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  + 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
- 가상 메모리 기본 아이디어
  + 프로세스는 가상 주소르 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸 때만 물리 주소로 바꿔주면 된다
  + virtual address (가상 주소): 프로세스가 참조한느 주소 (모든 프로세스는 0~4GB의 가상 주소를 가짐)
  + physical address (물리 주소): 실제 메모리 주소
- MMU(Memory Management Unit)
  + CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
  + CPU가 특정 프로세스의 공간을 참조할 때, 먼저 가상 주소를 찾고, 이 가상 주소가 어느 물리 주소에 들어있는지 알아낸다.   
  (가상주소:물리주소 변환) 이것을 빠르게 해주는 것이 MMU   
    
  > CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  > 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
  
  ![](http://pds15.egloos.com/pds/201001/24/90/c0098890_4b5c47fb7c7ba.jpg)  
  출처: <http://recipes.egloos.com/5232056>
  
  ## 페이징 시스템(paging system)
  - 페이징(paging( 개념
    + 크기가 돌일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    + 하드웨어 지원이 필요
      * 예) (CPU) Intel x86 tltmxpa(32bit)에서는 4KB, 2MB, 1GB 지원
    + 리눅스에서는 4KB로 paging
    + 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
    
  ### 페이징 시스템)paging system)
  - 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
  - Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음
  - CPU가 가상주소에 접근하려고 하면 가상주소를 보고 page번호를 얻고 PCB에 있는 Page Table에 가서 가상 주소에 매치 되어 있는 물리 주소에 들어가서 실제 데이터를 가져옴
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
